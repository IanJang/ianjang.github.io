[{"categories":["Django"],"content":"들어가며 PostgreSQL JSON Field에 대하여 ORM 구문 작성 시 exclude를 사용한다면 주의하길 바랍니다. JSON Field에 대한 질의 결과가 일반적인(?) 예상과는 조금 다른 결과가 나옵니다. 그 때문에 이 같은 내용을 모르고 사용한다면 혼란에 빠질 수 있습니다. 실제로 본인 포함한 여러 개발자가 동일한 케이스로 혼란을 겪은 경험이 있습니다. 본 글의 내용을 접한 분들은 동일한 혼란을 겪지 않을 수 있길 바랍니다. (본 글은 Django 3.0.7, psycopg2-binary 2.8.5, PostgreSQL 12.4 기준으로 테스트 후 작성되었습니다.) ","date":"2020-11-13","objectID":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/:1:0","tags":["Django","PostgreSQL","DjangoORM","JSONField"],"title":"Django ORM PostgreSQL JSONField에 대해 exclude 구문 사용시 주의사항","uri":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/"},{"categories":["Django"],"content":"JSON Field 필터링 테스트 아래 코드처럼 Book 모델이 구성되어 있고. 총 8개의 샘플 데이터가 있다고 가정합니다. # models.py class Book(models.Model): # (...생략...) data = JSONField(null=True, blank=True) # test_jsonfield_filter.py class TestJsonFieldFiltering(TestCase): def setUp(self): Book.objects.create(id=1, data=None) Book.objects.create(id=2, data={}) Book.objects.create(id=3, data={'title': 'django'}) Book.objects.create(id=4, data={'title': 'python'}) Book.objects.create(id=5, data={'title': 'django', 'is_published': True}) Book.objects.create(id=6, data={'title': 'python', 'is_published': True}) Book.objects.create(id=7, data={'title': 'django', 'is_published': False}) Book.objects.create(id=8, data={'title': 'python', 'is_published': False}) ","date":"2020-11-13","objectID":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/:2:0","tags":["Django","PostgreSQL","DjangoORM","JSONField"],"title":"Django ORM PostgreSQL JSONField에 대해 exclude 구문 사용시 주의사항","uri":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/"},{"categories":["Django"],"content":"filter 테스트 먼저 filter를 테스트해 봅시다. def test_filter(self): queryset = Book.objects.filter(data__is_published=True) row_id_set = set(queryset.values_list('id', flat=True)) self.assertEqual(row_id_set, {5, 6}) queryset = Book.objects.filter(data__is_published=False) row_id_set = set(queryset.values_list('id', flat=True)) self.assertEqual(row_id_set, {7, 8}) data__is_published=True로 필터 시 5, 6번 data가 조회되었고, data__is_published=False로 필터 시 7, 8번 데이터가 조회되었습니다. 의도한 대로 결과가 잘 조회됩니다. ","date":"2020-11-13","objectID":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/:2:1","tags":["Django","PostgreSQL","DjangoORM","JSONField"],"title":"Django ORM PostgreSQL JSONField에 대해 exclude 구문 사용시 주의사항","uri":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/"},{"categories":["Django"],"content":"exclude 테스트 다음으로 exclude에 대해 테스트를 해 봅시다. def test_exclude(self): queryset = Book.objects.exclude(data__is_published=True) row_id_set = set(queryset.values_list('id', flat=True)) self.assertEqual(row_id_set, {1, 2, 3, 4, 7, 8}) # AssertionError: Items in the second set but not the first: 2 3 4 Assertion Error가 발생했습니다. 의도 대로라면 is_published가 True로 세팅된 5, 6번을 제외한 1, 2, 3, 4, 7, 8번의 Book이 조회되어야 하는데, 결과는 1, 7, 8만 조회되었습니다. 이유가 무엇일까요? ","date":"2020-11-13","objectID":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/:2:2","tags":["Django","PostgreSQL","DjangoORM","JSONField"],"title":"Django ORM PostgreSQL JSONField에 대해 exclude 구문 사용시 주의사항","uri":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/"},{"categories":["Django"],"content":"JSON Field 필터링 시 SQL 질의문(Query) 확인 앞서 테스트한 ORM 구문에 대해서 실제로 어떤 Query가 Database에 요청되는지 확인해 봅시다. 먼저 filter query부터 확인해 봅시다. ","date":"2020-11-13","objectID":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/:3:0","tags":["Django","PostgreSQL","DjangoORM","JSONField"],"title":"Django ORM PostgreSQL JSONField에 대해 exclude 구문 사용시 주의사항","uri":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/"},{"categories":["Django"],"content":"filter query queryset = Book.objects.filter(data__is_published=True) print(queryset.query) SELECT (..생략..) FROM \"myapp_book\" WHERE \"myapp_book\".\"data\" -\u003e is_published = 'true' 특이 사항은 없어 보입니다. 다음은 exclude query를 확인해 봅시다. ","date":"2020-11-13","objectID":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/:3:1","tags":["Django","PostgreSQL","DjangoORM","JSONField"],"title":"Django ORM PostgreSQL JSONField에 대해 exclude 구문 사용시 주의사항","uri":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/"},{"categories":["Django"],"content":"exclude query queryset = DummyModel.objects.exclude(data__is_published=True) print(queryset.query) SELECT (..생략..) FROM \"myapp_book\" WHERE NOT \"myapp_book\".\"data\" -\u003e is_published = 'true' AND \"myapp_book\".\"data\" IS NOT NULL filter query와 달리 의도하지 않은 구문이 포함된 것이 보입니다. “myapp_book”.“data” IS NOT NULL 이것 때문인지 결과가 달라진 것은 아닐지 확인해 봤습니다. (결론부터 말하자면 해당 조건과는 무관했습니다) 일단 조건절 모양이 “NOT (A AND B)” 형태여서 눈에 잘 안 들어오니, 드모르간 법칙을 이용해 조건절을 보기 쉽게 “NOT A OR NOT B” 형태로 바꿔봤습니다. SELECT (..생략..) FROM \"myapp_book\" WHERE \"myapp_book\".\"data\" -\u003e is_published != 'true' OR \"myapp_book\".\"data\" IS NULL 풀어놓고 다시 보니 Query 구문 자체는 문제가 없어 보입니다. “myapp_book”.“data” -\u003e is_published != ‘true’ 조건만으로도 1, 2, 3, 4, 7, 8이 선택돼야 할 것처럼 보입니다. 아래 다이어그램처럼 말이죠…. Query 구문 확인으로도 여전히 의문은 풀리지 않았습니다. 그래서 이번엔 DB에 직접 Query를 날려 보며 결과를 확인해 봤습니다. ","date":"2020-11-13","objectID":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/:3:2","tags":["Django","PostgreSQL","DjangoORM","JSONField"],"title":"Django ORM PostgreSQL JSONField에 대해 exclude 구문 사용시 주의사항","uri":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/"},{"categories":["Django"],"content":"DB Query 수행 결과 확인 위에서 마지막으로 도출했던 Query 구문의 조건절을 분리하여 각각 Query를 수행해 보았습니다. # QUERY #1 postgres_db=# SELECT \"id\", \"data\" FROM \"myapp_book\" where \"myapp_book\".\"data\" IS NULL; id | data ----+------ 1 | (1 row) # QUERY #2 postgres_db=# SELECT \"id\", \"data\" FROM \"myapp_book\" where \"myapp_book\".\"data\" -\u003e 'is_published' != 'true'; id | data ----+-------------------------------------------- 7 | {\"title\": \"django\", \"is_published\": false} 8 | {\"title\": \"python\", \"is_published\": false} (2 rows) 원인을 찾았습니다. QUERY #2의 결과가 예상했던 1, 2, 3, 4, 7, 8이 아닌 달리 7, 8만 조회되네요. JSONField의 특정 key값에 대해서 조회 조건을 사용하면 해당 key값이 없는 row는 제외하고 결과가 조회됨을 알 수 있습니다. 몇 가지 더 테스트 해봤습니다. postgres_db=# SELECT \"id\", \"data\" FROM \"myapp_book\" WHERE \"myapp_book\".\"data\" -\u003e 'is_published' is null; id | data ----+--------------------- 1 | 2 | {} 3 | {\"title\": \"django\"} 4 | {\"title\": \"python\"} postgres_db=# SELECT \"id\", \"data\" FROM \"myapp_book\" WHERE \"myapp_book\".\"data\" -\u003e 'is_published' != 'true' or \"myapp_book\".\"data\" -\u003e 'is_published' is null; id | data ----+-------------------------------------------- 1 | 2 | {} 3 | {\"title\": \"django\"} 4 | {\"title\": \"python\"} 7 | {\"title\": \"django\", \"is_published\": false} 8 | {\"title\": \"python\", \"is_published\": false} (6 rows) JSON Field의 특정 key 값에 대해서 “is null” 조건으로 조회하면 None, {}, key가 없는 것 세 가지가 다 조회가 됩니다. JSON Field의 특정 key 값이 존재하는 row도 있고, 존재하지 않는 row도 있다면, 해당 key 값에 대해 “is null” 조건을 함께 사용해야 의도한 결과를 도출 할 수 있음을 알 수 있습니다. ","date":"2020-11-13","objectID":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/:3:3","tags":["Django","PostgreSQL","DjangoORM","JSONField"],"title":"Django ORM PostgreSQL JSONField에 대해 exclude 구문 사용시 주의사항","uri":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/"},{"categories":["Django"],"content":"기타 이슈 및 해결 ","date":"2020-11-13","objectID":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/:4:0","tags":["Django","PostgreSQL","DjangoORM","JSONField"],"title":"Django ORM PostgreSQL JSONField에 대해 exclude 구문 사용시 주의사항","uri":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/"},{"categories":["Django"],"content":"ERROR: column “is_published” does not exist 현상: queryset.query 결과를 그대로 psql에서 수행시켰을 때 해당 에러가 나왔습니다. 해결: “myapp_book”.“data” -\u003e is_published에서 is_published를 single quote로 감싸서 query를 수행했더니 결과가 정상적으로 나왔습니다. SELECT \"id\", \"data\" FROM \"myapp_book\" WHERE \"myapp_book\".\"data\" -\u003e is_published != 'true'; # (X) ERROR: column \"is_published\" does not exist SELECT \"id\", \"data\" FROM \"myapp_book\" WHERE \"myapp_book\".\"data\" -\u003e \"is_published\" != 'true'; # (X) ERROR: column \"is_published\" does not exist SELECT \"id\", \"data\" FROM \"myapp_book\" WHERE \"myapp_book\".\"data\" -\u003e 'is_published' != 'true'; # (O) 정상 동작 ","date":"2020-11-13","objectID":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/:4:1","tags":["Django","PostgreSQL","DjangoORM","JSONField"],"title":"Django ORM PostgreSQL JSONField에 대해 exclude 구문 사용시 주의사항","uri":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/"},{"categories":["Django"],"content":"맺으며 JSON Field에 대해 ORM 구문 작성 시 조회대상 Key 값 존재여부를 체크하는 습관을 들입시다. exclude보다는 filter를 사용합시다. exclude를 이용해서도 원하는 결과를 도출할 수 있지만, “NOT(A AND B)” 형태보다는 “A OR B” 형태가 훨씬 가독성이 높기 때문에 filter를 이용하는 편이 좋다고 생각합니다. # is_published=True 조건 조회 시, 아래 두 ORM 구문 모두 예상한 결과가 나옵니다. Book.objects.filter(data__is_published=True) # O Book.objects.filter(Q(data__is_published=True) \u0026 Q(data__is_published__isnull=False)) # O # is_published=False 조건 조회 시, 아래 두 ORM 구문 모두 예상한 결과가 나옵니다. Book.objects.filter(data__is_published=False) # O Book.objects.filter(Q(data__is_published=False) \u0026 Q(data__is_published__isnull=False)) # O # is_published=True 만 제외하고 조회하려면 주의가 필요합니다. (예상 결과: 1, 2, 3, 4, 7, 8) Book.objects.exclude(data__is_published=True) # 예상과 다르 결과가 나옵니다. Book.objects.exclude(Q(data__is_published=True) \u0026 Q(data__is_published__isnull=False) # 예상한 결과가 나옵니다. Book.objects.filter(Q(data__is_published=False) | Q(data__is_published__isnull=True) # 예상한 결과가 나오며 가장 추천하는 방법입니다. ","date":"2020-11-13","objectID":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/:5:0","tags":["Django","PostgreSQL","DjangoORM","JSONField"],"title":"Django ORM PostgreSQL JSONField에 대해 exclude 구문 사용시 주의사항","uri":"/django-orm-postgresql-jsonfield%EC%97%90-%EB%8C%80%ED%95%B4-exclude-%EA%B5%AC%EB%AC%B8-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/"},{"categories":["AWS"],"content":"들어가며 AWS CloudWatch를 이용하여 AWS Cloud Infrastructure에 대한 다양한 지표를 대시보드 형태로 구성하여 모니터링을 할 수 있습니다. 다만 EC2 내부의 디스크 공간(Disk Space)과 메모리 사용량(Memory Usage)을 모니터링하기 위해서는 별도 작업이 필요합니다. ","date":"2020-01-01","objectID":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/:1:0","tags":["EC2","CloudWatch","Lambda","Slack"],"title":"EC2 디스크 공간, 메모리 사용량 CloudWatch 지표 쌓기","uri":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/"},{"categories":["AWS"],"content":"EC2 내부에 지표 수집용 스크립트 설치 디스크 공간(Disk Space), 메모리 사용량(Memory Usage) 지표를 수집하고 싶은 EC2에 SSH 접속하여 아래 스크립트를 수행합시다. $ sudo apt-get update $ sudo apt-get install unzip $ sudo apt-get install libwww-perl libdatetime-perl $ curl \u003chttps://aws-cloudwatch.s3.amazonaws.com/downloads/CloudWatchMonitoringScripts-1.2.2.zip\u003e -O $ unzip CloudWatchMonitoringScripts-1.2.2.zip $ rm CloudWatchMonitoringScripts-1.2.2.zip $ cd aws-scripts-mon $ cp awscreds.template awscreds.conf 이후 아래 권한들이 부여된 IAM 계정을 생성하고, 해당 계정의 AccessKey, SecretAccessKey를 awscreds.conf 파일에 입력합시다. 필요권한 cloudwatch:PutMetricData cloudwatch:GetMetricStatistics cloudwatch:ListMetrics ","date":"2020-01-01","objectID":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/:2:0","tags":["EC2","CloudWatch","Lambda","Slack"],"title":"EC2 디스크 공간, 메모리 사용량 CloudWatch 지표 쌓기","uri":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/"},{"categories":["AWS"],"content":"지표 수집 동작 검증 아래 스크립트를 수행하여 결과를 확인합니다. “Verification completed successfully. No actual metrics sent to CloudWatch.” 메시지가 출력되면 성공입니다. $ ./mon-put-instance-data.pl --mem-util --disk-space-util --disk-path=/ --verify --verbose ","date":"2020-01-01","objectID":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/:3:0","tags":["EC2","CloudWatch","Lambda","Slack"],"title":"EC2 디스크 공간, 메모리 사용량 CloudWatch 지표 쌓기","uri":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/"},{"categories":["AWS"],"content":"Crontab 이용 주기적으로 지표 수집하기 지표 수집 동작 검증이 완료되었지 실제로 지표가 수집되고 있는 것은 아닙니다. 실제로 지표를 수집하려면 crontab을 이용하여 주기적으로 스크립트가 수행되도록 작업이 필요합니다. 아래 스크립트를 참고하여 추가 작업을 진행합니다. $ sudo crontab -e # 아래 내용 입력 */5 * * * * ${ScriptPath}/mon-put-instance-data.pl --mem-used-incl-cache-buff --mem-util --disk-space-util --disk-path=/ --from-cron ","date":"2020-01-01","objectID":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/:4:0","tags":["EC2","CloudWatch","Lambda","Slack"],"title":"EC2 디스크 공간, 메모리 사용량 CloudWatch 지표 쌓기","uri":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/"},{"categories":["AWS"],"content":"CloudWatch에서 지표 수집 여부 확인 모든 작업이 끝났다면 CloudWatch에 접속 후 아래 경로로 이동 후 지표가 잘 쌓이고 있는지 확인합시다. CloudWatch 접속 \u003e 좌측 지표 메뉴 선택 \u003e 하단 [사용자 지정 네임스페이스] 확인 \u003e System/Linux 선택 ","date":"2020-01-01","objectID":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/:5:0","tags":["EC2","CloudWatch","Lambda","Slack"],"title":"EC2 디스크 공간, 메모리 사용량 CloudWatch 지표 쌓기","uri":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/"},{"categories":["AWS"],"content":"CloudWatch 경보를 SNS, Lambda를 이용하여 Slack에 알리기 특정 EC2에 대해서 디스크 용량, 메모리 사용률이 위험수치에 도달했을 때 Slack에 알림이 되도록 작업 할 수 있습니다. 자세한 내용은 아래 링크를 참고합시다. https://brunch.co.kr/@alden/56 ","date":"2020-01-01","objectID":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/:6:0","tags":["EC2","CloudWatch","Lambda","Slack"],"title":"EC2 디스크 공간, 메모리 사용량 CloudWatch 지표 쌓기","uri":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/"},{"categories":["AWS"],"content":"맺으며 디스크 공간이 가득 차는 문제는 애플리케이션이 점진적으로 데이터가 쌓이는 구조로 되어 있다면 필연적으로 발생합니다. 이럴 때 데이터를 주기적으로 별도 공간에 백업 후 삭제하거나 하는 방안을 마련해야 합니다. 메모리 사용률은 트래픽 증가, 메모리 누수 등의 이유로 위험 수치에 도달할 수 있습니다. 본 글의 내용이 이러한 문제를 미연에 감지하고 예방하는 데 도움이 되길 바랍니다. ","date":"2020-01-01","objectID":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/:7:0","tags":["EC2","CloudWatch","Lambda","Slack"],"title":"EC2 디스크 공간, 메모리 사용량 CloudWatch 지표 쌓기","uri":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/"},{"categories":["AWS"],"content":"Reference https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/mon-scripts.html ","date":"2020-01-01","objectID":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/:8:0","tags":["EC2","CloudWatch","Lambda","Slack"],"title":"EC2 디스크 공간, 메모리 사용량 CloudWatch 지표 쌓기","uri":"/ec2-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B3%B5%EA%B0%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9%EB%9F%89-cloudwatch-%EC%A7%80%ED%91%9C-%EC%8C%93%EA%B8%B0/"},{"categories":["AWS"],"content":"들어가며 서비스 운영 중인 EC2의 디스크 용량이 가득 차는 문제가 발생할 수 있습니다. 이때 정지 시간(Downtime) 없이 디스크 용량을 늘릴 수 있습니다. 먼저 AWS Console 또는 AWS CLI를 이용하여 Volume 사이즈를 늘인 후 Volume이 연결된 EC2에 SSH 접속하여 Partition 확장을 해야 합니다. 더욱 자세한 내용은 본문을 참고 바랍니다. ","date":"2019-04-18","objectID":"/aws-ec2-volume-size-%EB%8A%98%EC%9D%B4%EA%B8%B0/:1:0","tags":["AWS","EC2","EBS"],"title":"구동 중인 AWS EC2 디스크 용량 늘리기","uri":"/aws-ec2-volume-size-%EB%8A%98%EC%9D%B4%EA%B8%B0/"},{"categories":["AWS"],"content":"EC2 Volume Size 수정 아래 순서대로 작업을 진행합시다. AWS Console 접속 \u003e Services \u003e EC2 \u003e Volumes 수정하려는 볼륨 선택 \u003e Actions - Modify Volume(볼륨수정) 선택 수정을 원하는 Size(크기) 입력 작업을 완료하고 나면 Volume의 상태가 “in-use - optimizing\"으로 변경됩니다. 이 상태가 “is-use completed\"로 바뀌면 Partition 확장 작업을 진행합시다. ","date":"2019-04-18","objectID":"/aws-ec2-volume-size-%EB%8A%98%EC%9D%B4%EA%B8%B0/:2:0","tags":["AWS","EC2","EBS"],"title":"구동 중인 AWS EC2 디스크 용량 늘리기","uri":"/aws-ec2-volume-size-%EB%8A%98%EC%9D%B4%EA%B8%B0/"},{"categories":["AWS"],"content":"Partition 확장 먼저 아래와 같이 lsblk 명령어를 이용하여 스토리지 블록을 점검합니다. 결과를 보면 disk와 root partition의 용량이 서로 다릅니다. disk에는 150GB가 할당됐지만, root partition에는 100GB만 할당된 것을 확인할 수 있습니다. ubuntu@my-ec2:~$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT xvda 202:0 0 150G 0 disk └─xvda1 202:1 0 100G 0 part / growpart 명령어를 이용하여 파티션을 확장합니다. ubuntu@my-ec2:~$ sudo growpart /dev/xvda 1 CHANGED: partition=1 start=16065 old: size=209699102 end=209715167 new: size=314556702,end=314572767 ubuntu@my-ec2:~$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT xvda 202:0 0 150G 0 disk └─xvda1 202:1 0 150G 0 part / resize2fs 명령을 이용하여 file system을 확장해주어야 마무리됩니다. ubuntu@my-ec2:~$ sudo resize2fs /dev/xvda1 resize2fs 1.42.13 (17-May-2015) Filesystem at /dev/xvda1 is mounted on /; on-line resizing required old_desc_blocks = 7, new_desc_blocks = 10 The filesystem on /dev/xvda1 is now 39319587 (4k) blocks long. # 확장이 잘 됐는지 확인 ubuntu@my-ec2:~$ df -h Filesystem Size Used Avail Use% Mounted on udev 7.9G 0 7.9G 0% /dev tmpfs 1.6G 169M 1.5G 11% /run /dev/xvda1 148G 27G 115G 19% / tmpfs 7.9G 0 7.9G 0% /dev/shm tmpfs 5.0M 0 5.0M 0% /run/lock tmpfs 7.9G 0 7.9G 0% /sys/fs/cgroup tmpfs 1.6G 0 1.6G 0% /run/user/1000 ","date":"2019-04-18","objectID":"/aws-ec2-volume-size-%EB%8A%98%EC%9D%B4%EA%B8%B0/:3:0","tags":["AWS","EC2","EBS"],"title":"구동 중인 AWS EC2 디스크 용량 늘리기","uri":"/aws-ec2-volume-size-%EB%8A%98%EC%9D%B4%EA%B8%B0/"},{"categories":["AWS"],"content":"맺으며 AWS를 이용하니 쉽고 간편한 작업을 통해 정지 시간(Downtime) 없이 EC2의 디스크 사이즈를 늘이는 데 성공했습니다. 이 글이 비슷한 문제를 겪는 분들에게 도움이 되었으면 합니다. ","date":"2019-04-18","objectID":"/aws-ec2-volume-size-%EB%8A%98%EC%9D%B4%EA%B8%B0/:4:0","tags":["AWS","EC2","EBS"],"title":"구동 중인 AWS EC2 디스크 용량 늘리기","uri":"/aws-ec2-volume-size-%EB%8A%98%EC%9D%B4%EA%B8%B0/"},{"categories":["AWS"],"content":"Reference https://support.amimoto-ami.com/english/self-hosting-accounts/increasing-your-ec2-volume-size https://aws.amazon.com/ko/blogs/aws/amazon-ebs-update-new-elastic-volumes-change-everything/ https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/requesting-ebs-volume-modifications.html#elastic-volumes-limitations ","date":"2019-04-18","objectID":"/aws-ec2-volume-size-%EB%8A%98%EC%9D%B4%EA%B8%B0/:5:0","tags":["AWS","EC2","EBS"],"title":"구동 중인 AWS EC2 디스크 용량 늘리기","uri":"/aws-ec2-volume-size-%EB%8A%98%EC%9D%B4%EA%B8%B0/"},{"categories":["AWS"],"content":"들어가며 이미지 리소스를 S3에 업로드 하면 자동으로 압축이 되게 할 순 없을까? AWS Lambda를 이용하면 이 같은 자동화된 기능을 구현하여 사용할 수 있습니다. 여러 가지 사례를 참고하여 직접 자동화 작업을 진행하고, 그 내용을 정리해 보았습니다. ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:1:0","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"ImageMagick 먼저 이미지 압축을 위해 사용한 ImageMagick을 소개합니다. ImageMagick은 이미지 변환용으로 널리 쓰이는 오픈소스 라이브러리입니다. 위키백과:이미지매직 ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:2:0","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"ImageMagick 설치 저는 먼저 우분투환경에서 ImageMagick을 설치하여 사용해 보았습니다. 아래 순서로 진행하였습니다. # PNG library 설치 $ sudo apt-get install libpng-dev # ImageMagick 설치 $ git clone https://github.com/ImageMagick/ImageMagick.git $ cd ImageMagick $ ./configure $ make $ sudo make install $ sudo ldconfig /usr/local/lib $ /usr/local/bin/convert logo: logo.gif $ make check Reference: https://imagemagick.org/script/install-source.php ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:2:1","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"Command Line Options 설치한 ImageMagick을 CLI로 사용하려고 보니 정말 다양한 옵션값이 있었습니다. 하지만 이 중 Quality 옵션만으로도 간단한 이미지 압축이 가능합니다. (단, 압축이 어려운 복잡한 이미지일 경우 용량이 되려 커지는 경우도 있습니다) 모든 Option 정보는 아래 링크를 참고합시다. https://www.imagemagick.org/script/command-line-options.php ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:2:2","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"이미지 포맷 별 Quality Option 값의 의미 이미지 포맷에 따라 quality가 의미하는 바가 다르다는 점에 유의해야 합니다. JPEG/MPEG 포맷의 경우 quality 값이 낮을수록 높은 압축률을 의미하고, MNG/PNG 포맷의 경우 quality 값이 높을 수록 높은 압축률을 의미합니다. 그뿐만 아니라 MNG/PNG 포맷의 경우는 quality 값에 의해 필터 타입도 결정됩니다. JPEG/MPEG: 1(압축률최대) ~ 100(압축률최저) MNG/PNG zlib compression level: (quality / 10) filter type: (quality % 10) Reference: https://www.imagemagick.org/script/command-line-options.php#quality ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:2:3","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"ImageMagick 명령어 아래는 image.png를 quality 80 옵션으로 변환한 image_compressed.png를 생성하는 명령어입니다. # Image Compression $ magick convert image.png -quality 80 image_compressed.png Reference: https://imagemagick.org/script/command-line-processing.php ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:2:4","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"Wand(ImageMagick for python) 지금까지 우분투 환경에서 ImageMagick을 설치하고 사용해 보았습니다. 이제 Python 코드 내에서 ImageMagick을 사용해 봅시다. 여러 가지 패키지가 있지만, 그중에서 Wand를 추천합니다. (PythonMagick, PythonMagickWand도 있지만, 이들은 마지막 Release 버전이 10년도 넘어서 사용하기 꺼려집니다) $ pip install wand 아래는 wand를 이용하여 PNG 이미지를 압축하는 Python 코드입니다. 좀 더 정확히 말하자면 origin/image1.png 파일을 “zlib_compression_level=8, filter_type=0” 옵션으로 압축한 파일을 compress/image1.png에 저장하는 코드입니다. from wand.image import Image with Image(filename='origin/image1.png') as img: img.compression_quality = 80 img.save(filename='compress/image1.png') ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:3:0","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"Lambda 함수 작성 이제 위에서 작성한 python 코드를 가지고 Lambda 함수를 작성해 봅시다. ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:4:0","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"환경변수 설정 S3 제어를 위해 access_key 및 secret_key 사용이 필요했고, 이를 lambda 함수의 환경변수로 세팅하고 코드에 사용했습니다. ACCESS_KEY = os.environ.get('ACCESS_KEY') SECRET_KEY = os.environ.get('SECRET_KEY') AWS Lambda \u003e 함수 선택 \u003e 환경변수에 설정하고, 위 코드처럼 가져다 쓰면 됩니다. ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:4:1","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"External Library를 포함하여 Lambda함수 생성하는 방법 AWS CLI 명령어를 이용하면 간편하게 External Library를 포함하여 Lambda 함수를 갱신할 수 있습니다. wand python 패키지를 lambda 함수에 포함해 보았습니다. # 패키지 설치용 폴더 생성 $ mkdir package $ cd package # 해당 경로에 패키지 설치 $ pip install wand --target . # zip파일로 압축 $ zip -r9 ../function.zip . $ cd .. # lambda 함수 소스코드를 압축파일에 추가 $ zip -g function.zip function.py # 압축 파일을 통하여 Lambda 함수 갱신 $ aws lambda update-function-code --function-name ${람다함수명} --zip-file fileb://function.zip Refecence https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/lambda-python-how-to-create-deployment-package.html [AWS docs] 자습서: Amazon S3과 함께 AWS Lambda 사용 ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:4:2","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"Lambda 함수 S3 event trigger 테스트 방법 아래 S3 ObjectCreated Event 샘플을 이용하여 테스트 이벤트를 구성하였습니다. 아래 코드 사용 시 파일에서 bucket과 object key 부분만 수정해서 사용하면 됩니다. 그 외 다른 Service의 Event가 필요하다면 Reference를 참고하여 테스트 이벤트를 구성하면 됩니다. { \"Records\": [ { \"eventVersion\": \"2.1\", \"eventSource\": \"aws:s3\", \"awsRegion\": \"ap-northeast-2\", \"eventTime\": \"2019-04-05T07:49:12.805Z\", \"eventName\": \"ObjectCreated:Put\", \"userIdentity\": { \"principalId\": \"AWS:생략\" }, \"requestParameters\": { \"sourceIPAddress\": \"###.###.##.##\" }, \"responseElements\": { \"x-amz-request-id\": \"생략\", \"x-amz-id-2\": \"생략\" }, \"s3\": { \"s3SchemaVersion\": \"1.0\", \"configurationId\": \"생략\", \"bucket\": { \"name\": \"s3.bucket.name\", \"ownerIdentity\": { \"principalId\": \"생략\" }, \"arn\": \"arn:aws:s3:::s3.bucket.name\" }, \"object\": { \"key\": \"object.key\", \"size\": 1024, \"eTag\": \"생략\", \"sequencer\": \"생략\" } } } ] } Reference: https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/eventsources.html ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:4:3","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"완성된 코드 최종적으로 완성된 코드는 아래 링크를 참고 부탁드립니다. https://github.com/IanJang/lambda-wand-image-convert ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:4:4","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"이슈 및 해결 ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:5:0","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"magick: no decode delegate for this image format `PNG’ 이와 같은 에러 메시지를 만난다면 libpng library가 없는 경우 입니다. sudo apt-get install libpng-dev 명령으로 라이브러리를 설치하면 해결됩니다. Reference: http://www.libpng.org/pub/png/libpng.html ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:5:1","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"Lambda Event가 무한히 Trigger 되는 문제 현상 S3에서 파일을 다운로드 로컬에서 변형 \u003e S3에 올리는 Lambda 함수를 구성하고, 이 함수의 Event Trigger로 s3 ObjectCreated Event를 연결했습니다. 이후 Lambda 함수가 s3 Event에 의해 Trigger 되어 잘 수행되는지 테스트를 진행했는데, Lambda 함수가 무한히 호출되는 현상이 발생했습니다. 원인 사용자가 S3에 파일을 원본 이미지를 업로드 하는 것도 S3 ObjectCreated Event를 발생시키지만, Lambda 함수 수행 후 변환된 이미지를 S3에 업로드 하는 것 또한 ObjectCreated Event를 발생시켰기 때문에 무한루프에 빠진 것이 원인이었습니다. 해결 S3 CreatedObject Event Trigger에 Object Prefix 조건을 걸면 됩니다. 특정 경로에 파일 업로드 시만 Event가 Trigger 되도록 제한할 수 있습니다. Lambda 함수 내부에서 S3에 파일을 다시 올려야 한다면 Event Trigger를 걸어놓은 경로는 피하는 게 좋습니다. 원본 이미지 업로드용 S3 Bucket과 변환 이미지 업로드용 S3 Bucket을 별도 구성해서 원본 이미지 업로드용 Bucket에만 Event Trigger를 거는 방법도 있습니다. ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:5:2","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"[ERROR] ClientError: An error occurred (404) when calling the HeadObject operation: Not Found Traceback (most recent call last) 현상 파일명이 test (1).png인 파일을 s3에 업로드 했더니 Lambda 함수 수행이 실패했습니다. 로그에는 제목과 같은 에러가 있었고 자세히 살펴보니 S3 ObjectCreated event에 포함된 object key 값이 test+%281%29.png과 같이 깨져있었습니다. 깨진 key 값 때문에 S3 파일 다운로드를 object를 찾지 못하고 에러가 발생한 것입니다. 원인 S3 event에 담아서 전달되는 object key 값은 URL 인코딩이 됩니다. 이를 디코딩 없이 사용한 것이 문제의 원인이었습니다. 해결 Object key를 디코딩하여 사용하도록 함수를 개선하였습니다. from urllib.parse import unquote_plus # (...생략...) decoded_key = unquote_plus(key) Reference: https://forums.aws.amazon.com/thread.jspa?threadID=215813 ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:5:3","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"Task timed out after 3.00 seconds 현상 앞서 만든 이미지 변환 Lambda 함수를 테스트했더니 용량이 큰 이미지 파일에 대해서는 제대로 동작하지 않고 위 제목과 같은 에러가 발생했습니다. 원인 친절한 에러 메세지덕에 timeout 문제임을 알 수 있었습니다. # CloudWatch 에러로그 REPORT RequestId: ae6e0aae-9ca4-4f1a-ac65-b23cf75bb4fd Duration: 3003.50 ms Billed Duration: 3000 ms Memory Size: 128 MB Max Memory Used: 65 MB 2019-04-05T01:15:03.289Z ae6e0aae-9ca4-4f1a-ac65-b23cf75bb4fd Task timed out after 3.00 seconds 해결 Lambda 함수 메모리를 128MB -\u003e 256MB로 늘여서 해결하였습니다. Lambda 함수 할당 메모리양을 증가시키면 그에 비례한 성능의 CPU가 Lambda 함수에 할당됩니다. 이로 인해 함수 수행속도가 빨라지지만, 비용도 그만큼 증가합니다. 비용과 성능의 적정 타협점을 찾는 게 중요할 것 같습니다. ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:5:4","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["AWS"],"content":"맺으며 AWS Lambda를 이용하여 서버리스 아키텍처를 아주 살짝 경험해 봤습니다. 별도 서버 구축 없이 기능을 구현하여 사용자에게 제공하는 경험은 신선했습니다. AWS Lambda는 적재적소에 잘만 사용하면 더 빠르고 효율적으로 고객의 요구사항을 해결할 수도 있는 유용한 서비스인 것 같습니다. ","date":"2019-04-05","objectID":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/:6:0","tags":["AWS","S3","Lambda"],"title":"AWS Lambda, S3를 이용한 이미지 변환 자동화(feat. ImageMagick)","uri":"/aws-lambda-s3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99%ED%99%94/"},{"categories":["Linux"],"content":"들어가며 서버 애플리케이션이 특정 경로에 파일(로그, 이미지 등)을 쌓는 구조로 되어 있다면 언젠가 용량이 가득 차는 문제를 맞이할 수 있습니다. 이를 예방하기 위해선 특정 기간이 지난 파일을 지우거나, 압축하여 별도 저장소로 옮긴다거나 하는 과정이 필요합니다. 간단한 shell 스크립트를 작성하고 crontab에 등록하여 이러한 과정을 자동화 할 수 있습니다. ","date":"2019-04-04","objectID":"/crontab-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A3%BC%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%98%A4%EB%9E%98%EB%90%9C-%ED%8C%8C%EC%9D%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/:1:0","tags":["Crontab","Linux"],"title":"Crontab 이용하여 주기적으로 오래된 파일 제거하기","uri":"/crontab-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A3%BC%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%98%A4%EB%9E%98%EB%90%9C-%ED%8C%8C%EC%9D%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/"},{"categories":["Linux"],"content":"Crontab 명령어 # crontab 추가 / 수정 $ crontab -e # crontab 확인 $ crontab -l # crontab 로그 확인 $ cat /var/log/syslog | grep CRON ","date":"2019-04-04","objectID":"/crontab-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A3%BC%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%98%A4%EB%9E%98%EB%90%9C-%ED%8C%8C%EC%9D%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/:2:0","tags":["Crontab","Linux"],"title":"Crontab 이용하여 주기적으로 오래된 파일 제거하기","uri":"/crontab-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A3%BC%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%98%A4%EB%9E%98%EB%90%9C-%ED%8C%8C%EC%9D%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/"},{"categories":["Linux"],"content":"오래된 파일을 제거하는 스크립트 작성하기 아래 정리된 명령어를 참고합시다. # * 수정한지 90일 이상 된 파일과 디렉토리 조회 $ find . -mtime +90 -ls # 수정한지 90일 이상된 파일만 조회 $ find . -mtime +90 -type f -ls # 수정한지 90일 이상된 파일만 삭제 # 정기적으로 90일지 지난 파일을 삭제할 때 유용 ) $ sudo find . -mtime +90 -type f -ls -exec rm -f {} \\\\; 아래는 직접 완성한 스크립트입니다. # remove_old_files.sh path = \"/home/ubuntu/work/data/\" days = 90 sudo find ${path} -mtime +${days} -type f -ls -exec rm -f {} \\\\; Reference https://zetawiki.com/wiki/리눅스_날짜_기준으로_파일_삭제하기 https://zetawiki.com/wiki/리눅스_n일전_파일_삭제 https://dbrang.tistory.com/867 ","date":"2019-04-04","objectID":"/crontab-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A3%BC%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%98%A4%EB%9E%98%EB%90%9C-%ED%8C%8C%EC%9D%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/:3:0","tags":["Crontab","Linux"],"title":"Crontab 이용하여 주기적으로 오래된 파일 제거하기","uri":"/crontab-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A3%BC%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%98%A4%EB%9E%98%EB%90%9C-%ED%8C%8C%EC%9D%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/"},{"categories":["Linux"],"content":"Crontab에 작업 등록하기 작성한 스크립트를 UTC기준 매일 15시 1분(KST기준 00시 1분)에 수행되도록 하였습니다. $ crontab -e # 아래 내용 입력 1 15 * * * /home/ubuntu/myscripts/remove_old_files.sh \u003e\u003e /home/ubuntu/myscripts/remove_old_files.sh.log 2\u003e\u00261 Reference: https://jdm.kr/blog/2 ","date":"2019-04-04","objectID":"/crontab-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A3%BC%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%98%A4%EB%9E%98%EB%90%9C-%ED%8C%8C%EC%9D%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/:4:0","tags":["Crontab","Linux"],"title":"Crontab 이용하여 주기적으로 오래된 파일 제거하기","uri":"/crontab-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A3%BC%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%98%A4%EB%9E%98%EB%90%9C-%ED%8C%8C%EC%9D%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/"},{"categories":["Linux"],"content":"이슈 및 해결 ","date":"2019-04-04","objectID":"/crontab-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A3%BC%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%98%A4%EB%9E%98%EB%90%9C-%ED%8C%8C%EC%9D%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/:5:0","tags":["Crontab","Linux"],"title":"Crontab 이용하여 주기적으로 오래된 파일 제거하기","uri":"/crontab-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A3%BC%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%98%A4%EB%9E%98%EB%90%9C-%ED%8C%8C%EC%9D%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/"},{"categories":["Linux"],"content":"Crontab default editor 변경 contab -e 명령 수행 시 nano editor가 열러 작업하기 불편하다면 아래 방법으로 에디터를 수정 할 수 있습니다. # 기본 에디터를 고르는 명령어 수행 $ select-editor # nano로 셋팅된것을, vim으로 변경 Select an editor. To change later, run 'select-editor'. 1. /bin/ed 2. /bin/nano \u003c---- easiest 3. /usr/bin/vim.basic 4. /usr/bin/vim.tiny Choose 1-4 [2]: 3 Reference: http://www.42.mach7x.com/2017/02/01/changing-default-editor-for-crontab-from-vi-to-vim/ ","date":"2019-04-04","objectID":"/crontab-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A3%BC%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%98%A4%EB%9E%98%EB%90%9C-%ED%8C%8C%EC%9D%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/:5:1","tags":["Crontab","Linux"],"title":"Crontab 이용하여 주기적으로 오래된 파일 제거하기","uri":"/crontab-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A3%BC%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%98%A4%EB%9E%98%EB%90%9C-%ED%8C%8C%EC%9D%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/"},{"categories":["Linux"],"content":"root 권한으로 crontab 작업을 등록하고 싶을 때 아래 명령을 이용하면 됩니다. 참고로 명령어에서 sudo를 빼면 현재 로그인된 계정에 대한 crontab 설정파일을 수정할 수 있습니다. $ sudo crontab -e Reference: https://askubuntu.com/questions/173924/how-to-run-a-cron-job-using-the-sudo-command ","date":"2019-04-04","objectID":"/crontab-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A3%BC%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%98%A4%EB%9E%98%EB%90%9C-%ED%8C%8C%EC%9D%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/:5:2","tags":["Crontab","Linux"],"title":"Crontab 이용하여 주기적으로 오래된 파일 제거하기","uri":"/crontab-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A3%BC%EA%B8%B0%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%98%A4%EB%9E%98%EB%90%9C-%ED%8C%8C%EC%9D%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/"},{"categories":["AWS"],"content":"들어가며 효과적인 영상 압축을 위해 AWS Media Convert 서비스를 사용해 보았습니다. 막상 사용하려고 보니 온통 처음 보는 용어가 가득했습니다. 이런 용어들을 이해해야 제대로 기능을 활용할 수 있을 것 같았습니다. 본문에는 기본적인 AWS Media Convert 서비스에 대한 소개와 더불어 각종 영상 압축 관련 용어들을 조금은 두서없이 정리해 보았습니다. ","date":"2019-03-11","objectID":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/:1:0","tags":["AWS","MediaConvert"],"title":"AWS Media Convert 파해치기","uri":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/"},{"categories":["AWS"],"content":"비용(Pricing) Basic Plan / AVC 코덱 / 아시아 태평양(서울) 리전 / On-Demand 요금 기준 fps\u003c=30 30\u003cfps\u003c=60 60\u003cfps\u003c=120 SD 0.0085 USD 0.0106 USD 0.0127 USD HD 0.0170 USD 0.0212 USD 0.0255 USD UHD 0.0340 USD 0.0425 USD 0.0510 USD RTS(ReservedTranscodeSlots) 요금 12개월 약정: 500 USD 추가 요금 Dolby Audio 분당 0.0050 USD 오디오 정규화 분당 0.0020 USD 베이직 티어와 프로페셔널 티어의 해상도는 아래와 같이 정의됩니다. SD: 수직해상도가 720 미만인 출력 480p: 720x480 60fps HD: 수직해상도가 720 이상이면서 1080 이하 출력 720p: 1280x720 60fps 1080i: 1920x1080 30fps(비월주사(인터레이즈.i)) FHD(1080p): 1920x1080 60fps UHD: 수직해상도가 1080보다 크면서 최대 2160인 출력 4K: 4096x2160 60 fps 비용 절감 방안 RDS를 활용합시다. 온 디멘드 요금 기준 393 시간 사용시 약 $500의 비용이 듦니다. 720p(0.0212 USD/분) x 23,585분(393시간) -\u003e 약 500 USD 월 393시간 미만의 영상을 인코딩 한다면 온 디멘드 요금제를 사용하고 그 이상 사용한다면 RTS를 두고 사용하면 비용 측면에서 유리합니다. Reference [AWS Document]AWS Elemental MediaConvert 요금 [블로그]빠르크의 3분강좌-해상도(frame resolution) ","date":"2019-03-11","objectID":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/:2:0","tags":["AWS","MediaConvert"],"title":"AWS Media Convert 파해치기","uri":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/"},{"categories":["AWS"],"content":"Output Groups ","date":"2019-03-11","objectID":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/:3:0","tags":["AWS","MediaConvert"],"title":"AWS Media Convert 파해치기","uri":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/"},{"categories":["AWS"],"content":"Apple HLS Group Setting Segment Segment control Segmented files: 기본 Single File: 하나의 Segment만 생성합니다. segment를 나눈 것과 성능상의 큰 차이는 없습니다. master manifest 파일에는 ts 정보가 아닌 byte 정보가 담깁니다. Segment length(sec) live는 보통 2초로 세팅하면 됩니다. Segment가 길수록 파일 사이즈가 커지고, 최초 ts 다운로드 시 오래 걸리게 됩니다. VOD는 굳이 자를 필요는 없습니다. (추천: 4초 이상 안 쓰는 게 좋습니다.) Codec specification RFC4281(default) RFC6381 ","date":"2019-03-11","objectID":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/:3:1","tags":["AWS","MediaConvert"],"title":"AWS Media Convert 파해치기","uri":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/"},{"categories":["AWS"],"content":"Output Settings(H.264) Preset Name modifier 세팅. 생성되는 파일의 post_fix Add I-Frame only manifest 사용하면 플레이어의 비디오 미리 보기에서 콘텐츠 스크러빙을 더 쉽게 지원할 수 있습니다. Reference: [AWS Document] AWS Elemental MediaLive, I-프레임 전용 HLS 매니페스트 및 JPEG 출력 기능 추가 ","date":"2019-03-11","objectID":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/:3:2","tags":["AWS","MediaConvert"],"title":"AWS Media Convert 파해치기","uri":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/"},{"categories":["AWS"],"content":"Encoding Settings AFD(Active Format Description) [위키피디아]액티브 포맷 디스크립션 SEI(Supplemental Enhancement Information) H.264의 임의액세스(영상 비트열 중간부터 재생가능하게 해주는 기능)를 위한 정보 프레임 Reference [AWS Document]출력 타임 코드 설정 조정 Framerate 기본적으로 소스를 따르게 설정 합니다. Video Mode Rate control mode CBR: 비트레이트가 일정 VBR: 정해진 값에서 비트레이트가 오르락 내리락 QVBR: 쉬운영상이 나오면 낮은 비트레이트 어려운 영상이 나오면 높은 비트레이트 Quality tuning Level / Max bitrate(bits/s) / QVBR Quality level Reference: [AWS Document] QVBR 속도 제어 모드 사용 해상도 너비 높이 QVBR 품질수준 최대 비트레이트 1,080p 1,920 1,080 9 6,000,000 720p 1,280 720 8 4,000,000 720p 1,280 720 7 2,000,000 480p 640 480 7 1,000,000 360p 480 360 7 700,000 240p 352 240 7 350,000 HRD Buffer GOP(Group of Pictures) I frame의 간격을 말합니다. B frame 2개일 경우: IBBPBBPBBPBBPBBPBBPBBP…I I: Key frame / B: 예측 frame / P: 참조 frame I frame이 용량이 제일 크고 B프레임이 용량이 제일 작습니다. 쉬운 영상(역동적이지 않은)일수록 B frame을 많이 쓰는 것이 유리합니다. 낮은 대역폭에 대해서는 B frame을 많이 쓰는 것이 유리합니다. 애니메이션은 Easy한 소스여서 bitrate를 낮춰도 크게 영상에 문제가 생기거나 하지 않습니다. 720p라면 일반적으로 2Mbps를 쓰지만 1.5Mbps로도 충분하고, QVBR Target 7 쓰면 CDN비용 40%이상 Save 할것으로 예상합니다. GOP size는 60, B frames between reference frames는 2~3 정도 쓰는것이 좋습니다. Reference: [위키피디아]IPB Frame - Video compression picture types Scene Change Detection I프레임을 중간에 삽입해줍니다. Profile BaseLine(CBP/BP) 저비용 어플리케이션(영상회의/모바일 어플리케이션 등)에 사용합니다. 영상손실, 인코더 기능을 특정 Basic한 것만으로 제한하는 방식입니다. 양방향 예측(B-Frame)은 지원하지 않습니다. Main(MP) 디지털 TV 방송 표준 양방향 예측(B-Frame)을 지원합니다. High(HiP) 고해상도 TV어플리케이션 Bluray Disc, DVB HDTV 방송 서비스에 사용합니다. 양방향 예측(B-Frame)을 지원합니다. Reference H.264/MPEG-4 AVC Profiles H.264/MPEG-4 AVC Profiles KOR Level 비트율, 프레임율, 화면해상도 서비스하려는 단말기 중에서 가장 낮은 레벨이 무엇인지 확인해야 합니다. Entropy Encoding 비디오 재생시에 CAVLC과 CABAC의 성능 차이는 거의 없는 반면에 화면의 질은 CABAC이 낫습니다. CABAC: 상황 적응 이진 산술 코딩. 기본 확률 모델에 대한 고효율 자동 조정을 제공합니다. 산술코더, 가장 높은 압축 효율 비율. CAVLC보다 많은 하드웨어 리소스가 필요합니다. CAVLC: 상황 적응 가변 길이 코딩. 호프만과 같은 압축 알고리즘 사용합니다. 적절한 품질. 빠른 데이터 압축 Reference: http://www.rumpus.co.kr/04.Technology/TransCoderTab04.asp Slice 화면을 독립적으로 분할하여 인코딩 가능합니다. 여러 CPU를 동시에 사용할 수 있습니다. 각 슬라이스 간의 중복되는 부분을 알 수 없습니다 인코딩 품질이 떨어질 수 있습니다. ","date":"2019-03-11","objectID":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/:3:3","tags":["AWS","MediaConvert"],"title":"AWS Media Convert 파해치기","uri":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/"},{"categories":["AWS"],"content":"Audio encoding settings profile HE-AAC: 디지털 오디오에서 쓰이는 손실 데이터 압축 방식 LC: 복잡성이 낮고, 스트리밍 오디오와 같은 낮은 비트레이트 애플리케이션에 최적화됩니다. HEV1: 스펙트럼 대역 복제(Spectral band replication, SBR)를 사용하여 주파수 영역(frequency domain)에서 압축 효율이 향상됩니다. HEV2: 스펙트럼 대역 복제와 파라메트릭 스테레오(PS)가 한 쌍을 이루어 스테레오 신호의 압축 효율이 향상됩니다. 박수와 같은 압축하기 어렵다고 알려진 음원에서는 음질의 열화가 발생한다고 알려져 있습니다. Reference: [위키피디아]HE-AAC Bitrate control mode CBR VBR ","date":"2019-03-11","objectID":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/:3:4","tags":["AWS","MediaConvert"],"title":"AWS Media Convert 파해치기","uri":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/"},{"categories":["AWS"],"content":"Media 서비스 제공 Origin MediaStore 심플하게 라이브 스트리밍을 구성할 경우 사용합니다. MediaPackage 보다 복잡한 구성시 사용합니다. S3 VOD 용 MetaData 업데이트가 안되서 Live용으로는 사용 불가능 합니다. ","date":"2019-03-11","objectID":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/:4:0","tags":["AWS","MediaConvert"],"title":"AWS Media Convert 파해치기","uri":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/"},{"categories":["AWS"],"content":"CDN Data Size가 비용과 연결됩니다. Profile Ordering 프로파일 제공 순서입니다. 대부분 낮은 것부터 올라가도록 세팅합니다. 다만, 충분히 네트워크 속도가 빠른 상태에서는 굳이 내려받지 않아도 되는 해상도의 세그먼트까지 다운받게 되어, 비용 낭비가 생깁니다. 추천사항은 720p \u003e 480p \u003e 1080p와 같이 적당히 중간 것부터 제공하도록 세팅하는 것입니다. ","date":"2019-03-11","objectID":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/:5:0","tags":["AWS","MediaConvert"],"title":"AWS Media Convert 파해치기","uri":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/"},{"categories":["AWS"],"content":"배경지식 OTT(Over The Top) 인터넷을 통해서 미디어 서비스를 받을 수 있는 모든 Device를 말합니다. HLS 전세게적으로 90% 정도 사용 합니다. 애플에서 만든 Adaptive Bitrate Streaming Master Manifest(index.m3u8) -\u003e 사용자별로 다르게 구성할 수 있습니다. Child Manifest(index_720p.m3u8) Child Manifest(index_480p.m3u8) Child Manifest(index_360p.m3u8) Live 용 HLS 컨버팅시 파일 생성순서 TS -\u003e Child manifest -\u003e Master Manifest Reference: [Tistory]개똥이야기-H.264소개 ","date":"2019-03-11","objectID":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/:6:0","tags":["AWS","MediaConvert"],"title":"AWS Media Convert 파해치기","uri":"/aws-media-convert-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/"},{"categories":["ETC"],"content":"들어가며 윈도우 환경에서 Jekyll을 사용해 보고 그 내용을 정리해 보았습니다. ","date":"2017-04-01","objectID":"/jekyll-template-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/:1:0","tags":["ETC","Jekyll"],"title":"Jekyll Template 적용하기","uri":"/jekyll-template-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"categories":["ETC"],"content":"마음에 드는 템플릿 찾기 우선 아래 사이트 중, 혹은 구글링을 통해 마음에 드는 jekyll 템플릿을 찾습니다. http://jekyllthemes.org/ https://jekyllthemes.io/ https://github.com/jekyll/jekyll/wiki/Themes 저는 lanyon-plus을 선택했습니다. 군더더기 없이 심플한 UI가 무척 맘에 들었습니다. lanyon-plus github repo: https://github.com/dyndna/lanyon-plus ","date":"2017-04-01","objectID":"/jekyll-template-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/:2:0","tags":["ETC","Jekyll"],"title":"Jekyll Template 적용하기","uri":"/jekyll-template-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"categories":["ETC"],"content":"템플릿 다운로드 아마도 대부분의 jekyll 템플릿이 github에 공유되어 있을 것입니다. 아래 명령으로 내려 받습니다. $ git clone https://github.com/dyndna/lanyon-plus.git ","date":"2017-04-01","objectID":"/jekyll-template-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/:3:0","tags":["ETC","Jekyll"],"title":"Jekyll Template 적용하기","uri":"/jekyll-template-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"categories":["ETC"],"content":"Package 설치 템플릿을 다운받은 경로에서 jekyll을 구동해봅시다. $ jekyll serve 아마도 잘 되지 않을것이며, 아래와 같은 에러메시지를 마주할 것입니다. C:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/spec_set.rb:87:in `block in materialize': Could not find i18n-0.7.0 in any of the sources (Bundler::GemNotFound) from C:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/spec_set.rb:80:in `map!' from C:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/spec_set.rb:80:in `materialize' from C:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/definition.rb:176:in `specs' from C:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/definition.rb:235:in `specs_for' from C:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/definition.rb:224:in `requested_specs' from C:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/runtime.rb:118:in `block in definition_method' from C:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler/runtime.rb:19:in `setup' from C:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/bundler-1.14.6/lib/bundler.rb:100:in `setup' from C:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/jekyll-3.3.1/lib/jekyll/plugin_manager.rb:36:in `require_from_bundler' from C:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/jekyll-3.3.1/exe/jekyll:9:in `\u003ctop (required)\u003e' from C:/Ruby23-x64/bin/jekyll:22:in `load' from C:/Ruby23-x64/bin/jekyll:22:in `\u003cmain\u003e' jekyll은 ruby 기반으로 만들어졌고, 그렇기에 jekyll 템플릿들은 저마다 다양한 ruby package들을 활용하고 있습니다. 그 때문에 개발환경이 서로 다르게 되면 jekyll이 제대로 동작하지 않을 수 있습니다. ruby에는 bundler라는 것이 존재합니다. 이를 이용하여 문제를 해결할 수 있습니다. ","date":"2017-04-01","objectID":"/jekyll-template-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/:4:0","tags":["ETC","Jekyll"],"title":"Jekyll Template 적용하기","uri":"/jekyll-template-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"categories":["ETC"],"content":"Bundler jekyll 템플릿이 설치된 폴더를 살펴보면 Gemfile, Gemfile.lock 찾을 수 있습니다. 이곳에는 해당 템플릿이 참고한 package 그 version의 spec 상세히 정리되어있고 한 번의 명령어 수행만으로 모두 설치할 수 있습니다. bundler가 설치되어있지 않다면 이부터 설치합시다. $ gem install bundler bundler가 설치되었다면 Gemfile이 존재하는 경로에서 아래 명령을 수행합시다. $ bundle install ","date":"2017-04-01","objectID":"/jekyll-template-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/:5:0","tags":["ETC","Jekyll"],"title":"Jekyll Template 적용하기","uri":"/jekyll-template-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"categories":["ETC"],"content":"jekyll 구동하기 준비가 완료되었습니다. 아래 명령어로 jekyll을 구동해봅시다. $ jekyll serve Reference https://github.com/dyndna/lanyon-plus http://guides.rubygems.org/rubygems-basics/ http://ruby-korea.github.io/bundler-site/ http://bundler.io/v1.6/git.html ","date":"2017-04-01","objectID":"/jekyll-template-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/:6:0","tags":["ETC","Jekyll"],"title":"Jekyll Template 적용하기","uri":"/jekyll-template-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"categories":["ETC"],"content":"들어가며 블로깅을 하기로 결심하고서, 이에 적합한 Markdown Editor를 찾다보니 굉장히 다양한 Markdown Tool이 있더라. 걔중에는 유료툴도 있고, 한국인 개발자가 만든 하루패드(Haroo pad)도 매우 평이 좋았다. 어떤것을 쓸까 고민하던 중 문득 Sublime Text에 Markdown용 Plugin이 있지 않을까 하는 생각이 들었다. 역시나 다양한 Plugin들이 존재했고, 그중 몇가지를 소개하려한다. 나무위키:마크다운 What is MarkDown? ","date":"2017-03-04","objectID":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/:1:0","tags":["ETC","SublimeText"],"title":"Sublime Text3에서 Markdown 문서 작성하기","uri":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/"},{"categories":["ETC"],"content":"Markdown Editing \u0026 Markdown Preview Markdown Editing은 Markdown 문법으로 문서작성을 할 수 있도록 도와준다. 세가지 문법(Standard Markdown, GitHub flavored Markdown, MultiMarkdown) 을 지원하고, Syntax Highlighting과 몇 가지 Color scheme 제공한다. Markdown Preview는 작성한 Markdown 문서를 브라우저를 통하여 Preview 할 수 있는 기능을 제공한다. ","date":"2017-03-04","objectID":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/:2:0","tags":["ETC","SublimeText"],"title":"Sublime Text3에서 Markdown 문서 작성하기","uri":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/"},{"categories":["ETC"],"content":"사용방법 Sublime Text3를 실행한다. Clt+Shift+P를 누르고 Package Control: Install Package를 선택한다. 각각의 Plugin을 찾아 설치한다. Markdown Editing Markdown Preview Preferences -\u003e Key Bindings에 단축키를 추가한다. [{ ... },{ \"keys\": [\"alt+m\"], \"command\": \"markdown_preview\", \"args\": { \"target\": \"browser\", \"parser\": \"markdown\" } }] Markdown 문서 작성 후 ALT++M을 눌러 내용을 확인한다. P.S 하얀색 테마가 마음에 안들면 검은색으로 바꾸자. 아래 내용을 Preferences -\u003e Package Settings -\u003e Markdown Editing -\u003e Markdown GFM Settings - User에 추가하자. { //\"color_scheme\": \"Packages/MarkdownEditing/MarkdownEditor.tmTheme\", \"color_scheme\": \"Packages/MarkdownEditing/MarkdownEditor-Dark.tmTheme\", // \"color_scheme\": \"Packages/MarkdownEditing/MarkdownEditor-Yellow.tmTheme\", } ","date":"2017-03-04","objectID":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/:2:1","tags":["ETC","SublimeText"],"title":"Sublime Text3에서 Markdown 문서 작성하기","uri":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/"},{"categories":["ETC"],"content":"Reference Markdown Editing \u0026 Markdown Preview 설치 관련 http://cheng.logdown.com/posts/2015/06/30/sublime-text-3-markdown ","date":"2017-03-04","objectID":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/:2:2","tags":["ETC","SublimeText"],"title":"Sublime Text3에서 Markdown 문서 작성하기","uri":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/"},{"categories":["ETC"],"content":"LiveReload(Optional) Markdown Editing, Markdown Preview만 이용하면 한가지 단점이 있다. 매번 수정사항이 생길 때마다 브라우저에서 F5버튼을 눌러서 Refresh를 해줘야 한다는 점이다. 이를 보완하기 위해 개발된 Plugin으로, 이를 이용하면 실시간으로 변경사항을 브라우저에서 확인할 수 있다. 다만 브라우저 확장 프로그램을 설치해야 한다는 번거로움이 있다. ","date":"2017-03-04","objectID":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/:3:0","tags":["ETC","SublimeText"],"title":"Sublime Text3에서 Markdown 문서 작성하기","uri":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/"},{"categories":["ETC"],"content":"사용방법 Sublime Text3를 실행한다. Clt+Shift+P를 누르고 Package Control: Install Package를 선택한다. LiveReload plugin을 찾아 설치한다. (Markdown Editing, Markdown Preview도 설치된 상태여야함) Chrome을 기본 브라우저로 활용하는 경우 확장 프로그램으로 liveReload를 찾아 설치한다. 확장 프로그램 설치 링크 Preferences -\u003e Package Settings -\u003e LiveReload -\u003e Setting - User 에 아래 내용을 추가한다. { \"enabled_plugins\": [ \"SimpleReloadPlugin\", \"SimpleRefresh\" ] } 준비 완료다. Alt+M를 눌러 Preview를 브라우저에 띄워놓은 채로 내용을 수정한뒤 저장(Clt+S)해보자. 새로고침 없이도 수정사항이 바로 반영됨을 확인할 수 있다. 추가사항 : 확장자를 .md로 저장하지 않으면 동작하지 않음 ","date":"2017-03-04","objectID":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/:3:1","tags":["ETC","SublimeText"],"title":"Sublime Text3에서 Markdown 문서 작성하기","uri":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/"},{"categories":["ETC"],"content":"Reference LiveReload 설치 관련 http://stackoverflow.com/questions/25886011/how-do-i-install-livereload-on-sublime-text-3 ","date":"2017-03-04","objectID":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/:3:2","tags":["ETC","SublimeText"],"title":"Sublime Text3에서 Markdown 문서 작성하기","uri":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/"},{"categories":["ETC"],"content":"Markdown Live Preview Markdown Preview의 대안으로, 결과물을 Sublime Text 자체에서 창을 Split하여 보여준다. 게다가 실시간으로 변경사항이 반영된다. 사용해본 결과 굉장히 편리하나 개인적으로는 위에서 언급한 방법을 선호한다. 각자 호불호에 맞게 사용하면 좋을 것 같다. Sublime Text3를 실행한다. Clt+Shift+P를 누르고 Package Control: Install Package를 선택한다. 각각의 Plugin을 찾아 설치한다. Markdown Editing MarkdownLivePreview ALT+M을 누르면 새창이 열리고 Split된 화면에서 결과물을 실시간으로 확인 할 수 있다. ","date":"2017-03-04","objectID":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/:4:0","tags":["ETC","SublimeText"],"title":"Sublime Text3에서 Markdown 문서 작성하기","uri":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/"},{"categories":["ETC"],"content":"Reference https://github.com/math2001/MarkdownLivePreview ","date":"2017-03-04","objectID":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/:4:1","tags":["ETC","SublimeText"],"title":"Sublime Text3에서 Markdown 문서 작성하기","uri":"/sublimetext3%EC%97%90%EC%84%9C-markdown-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/"},{"categories":["Python"],"content":"들어가며 pymysql을 이용해서 flask에서 Database를 다뤄봤다. 헌데 뭔가 부족한 감이있다. 자원을 체계적으로 관리하기 힘들어 보였다. 그래서 다른 모듈이 있지 않을까 하여 구글링해보았다. 그 결과 SQLAlchemy 또는 Flask-SQLAlchemy를 이용한 케이스들이 많더라. 어떤것을 사용하는게 좋을까? ","date":"2017-02-09","objectID":"/python-flask-with-sqlalchemy/:1:0","tags":["Python","Flask","SQLAlchemy"],"title":"Python Flask with SQLAlchemy","uri":"/python-flask-with-sqlalchemy/"},{"categories":["Python"],"content":"SQLAlchemy vs. Flask-SQLAlchemy 우선 지속적으로 관리가 되고 있는지가 궁금했다. Github에서 각각의 repository를 살펴봤다. 먼저 Flask-SQLAlchemy는 2.1 버전이 stable한 버전이며 2015년 10월 23일에 Release 되었다. 반면 SQLAlchemy는 22일 전인 2017년 1월 18일에 1.1.5 버전이 release 되었으며, Release history를 보면 꾸준히 버전이 Update 되고 있음을 확인할 수 있었다. 그래서 SQLAlchemy를 쓰기로 결정했다. Reference Flask-SQLAlchemy Github SQLAlchemy Github ","date":"2017-02-09","objectID":"/python-flask-with-sqlalchemy/:2:0","tags":["Python","Flask","SQLAlchemy"],"title":"Python Flask with SQLAlchemy","uri":"/python-flask-with-sqlalchemy/"},{"categories":["Python"],"content":"SQLAlchemy 시작하기 먼저 SQLAlchemy를 설치하자. $ pip install sqlalchemy 최신 버전인 1.1.5 버전이 설치됬다. Collecting sqlalchemy Downloading SQLAlchemy-1.1.5.tar.gz (5.1MB) 100% |████████████████████████████████| 5.1MB 155kB/s Installing collected packages: sqlalchemy Running setup.py install for sqlalchemy ... done Successfully installed sqlalchemy-1.1.5 본격적으로 이용 방법을 알아보자. 아래는 API 문서링크이다. SQLAlchemy official API Doc 먼저 database.py를 작성하자. # database.py from sqlalchemy import create_engine from sqlalchemy.orm import scoped_session, sessionmaker from sqlalchemy.ext.declarative import declarative_base engine = create_engine( \"mysql://test:test@localhost/test_database\", isolation_level=\"READ_UNCOMMITTED\" ) db_session = scoped_session( sessionmaker( autocommit=False, autoflush=False, bind=engine ) ) Base = declarative_base() Base.query = db_session.query_property() def init_db(): import yourapplication.models Base.metadata.create_all(bind=engine) create_engine()의 두 파라미터를 통해서 DB Connection 정보와 Transation Isolation level을 설정한다. ","date":"2017-02-09","objectID":"/python-flask-with-sqlalchemy/:3:0","tags":["Python","Flask","SQLAlchemy"],"title":"Python Flask with SQLAlchemy","uri":"/python-flask-with-sqlalchemy/"},{"categories":["Python"],"content":"Transaction Isolation Level READ COMMITTED READ UNCOMMITTED REPEATABLE READ SERIALIZABLE AUTOCOMMIT 위 다섯가지 종류를 지원한다. 혹 Transaction Isolation Level에 대해 잘 모른다면 데이터베이스 Isolation Level을 참고. 다음으로 scoped_session을 이용하여 session을 생성한다. 이를 이용하면 내부적으로 Thread 처리를 해주기 때문에 편리하다. declarative_base()을 호출하여 생성한 Base는 Table과 mapper를 만들기 위한 역할 한다. 이어서 모델을 만들자. 특정 사이트를 크롤링해서 링크를 정도를 걸기위한 목적으로 아래와 같은 모델을 구성해보았다. # models.py from sqlalchemy import Column, Integer, String from database import Base class Summary(Base): __tablename__ = 'suit_summary' summary_id = Column(Integer, primary_key=True) site_cd = Column(String(20)) category = Column(String(20)) content_no = Column(Integer,) subject = Column(String(100)) writer = Column(String(20)) write_date = Column(String(20)) hit_cnt = Column(Integer,) content_link = Column(String(100)) create_date = Column(String(20)) def __init__(self, site_cd=None, category=None, content_no=None, subject=None, writer=None, write_date=None, hit_cnt=None, content_link=None, create_date=None): self.site_cd = site_cd self.category = category self.content_no = content_no self.subject = subject self.writer = writer self.write_date = write_date self.hit_cnt = hit_cnt self.content_link = content_link self.create_date = create_date def __repr__(self): return '\u003cSummary %r\u003e' % (self.subject) DB Table과 적절히 매핑되기 위해 필드를 구성하고, __init__와 __repr__함수를 작성하자. init(self, …)는 생성자, repr(self)는 print를 했을 시 출력형태를 정의하는 함수다. ","date":"2017-02-09","objectID":"/python-flask-with-sqlalchemy/:3:1","tags":["Python","Flask","SQLAlchemy"],"title":"Python Flask with SQLAlchemy","uri":"/python-flask-with-sqlalchemy/"},{"categories":["Python"],"content":"Issue and Solution ","date":"2017-02-09","objectID":"/python-flask-with-sqlalchemy/:4:0","tags":["Python","Flask","SQLAlchemy"],"title":"Python Flask with SQLAlchemy","uri":"/python-flask-with-sqlalchemy/"},{"categories":["Python"],"content":"ModuleNotFoundError: No module named ‘MySQLdb’ 앱을 실행시켰더니 아래와같은 에러가 나왔다. Traceback (most recent call last): File \"D:\\workspace\\SuitFlaskApp\\suit\\database.py\", line 12, in \u003cmodule\u003e isolation_level=\"READ_UNCOMMITTED\" File \"C:\\Python36\\lib\\site-packages\\sqlalchemy\\engine\\__init__.py\", line 387, in create_engine return strategy.create(*args, **kwargs) File \"C:\\Python36\\lib\\site-packages\\sqlalchemy\\engine\\strategies.py\", line 80, in create dbapi = dialect_cls.dbapi(**dbapi_args) File \"C:\\Python36\\lib\\site-packages\\sqlalchemy\\dialects\\mysql\\mysqldb.py\", line 110, in dbapi return __import__('MySQLdb') ModuleNotFoundError: No module named 'MySQLdb' 에러가 나는 부분은 engine = create_engine( \"mysql://test:test@localhost/test_database\", isolation_level=\"READ_UNCOMMITTED\" ) MySQLdb 모듈이 없다고 한다. pip를 이용하여 설치하자 $ pip install MySQLdb 그 결과 Could not find a version that satisfies the requirement MySQLdb (from versions: ) No matching distribution found for MySQLdb 심플하게 해결될 문제일 줄 알았으나 해당 모듈이없단다. 구글링해보니 http://stackoverflow.com/questions/454854/no-module-named-mysqldb python 3.x 에는 MySQLdb가 없단다!. 현재 python3.6기반의 환경을 세팅한상태. 이럴수가.. 그런데 아래 mysqlclient를 이용하면 된다는 얘기가 있기에 시도해보았다. $ pip install mysqlclient 그후에 실행.. 역시 안된다. 다시 구글링해서 얻은 답변은 http://stackoverflow.com/questions/41824551/mysqldb-with-python-3-6 try to use sqlalchemy that is fully suported for many ODBC driver. Insted of using mysqldb, mysqlconnector is better in python3.x. I migrated a project from sqlite to mysql server and work fine in python3.6 sqlalchemy offer a solution for connecting with another ODBC. SQLalchemy는 많은 ODBC 드라이버를 지원하지만, MYSQLDB만 지원하지 않는단다. 좌절 포기할수 없다. 조금더 찾아보자 http://stackoverflow.com/questions/27766794/switching-from-sqlite-to-mysql-with-flask-sqlalchemy It happened to me that the default driver used by SQLAlchemy (mqsqldb), doesn’t get compiled for me in my virtual environments. So I have opted for a MySQL driver with full python implementation pymysql. Once you install it using pip install pymysql, the SQLALCHEMY_DATABASE_URI will change to: app.config[‘SQLALCHEMY_DATABASE_URI’] = ‘mysql+pymysql://username:password@localhost/db_name’ pymysql을 이용하면 된다고한다. pymysql을 설치하고, 코드를 변경했다 $ pip install pymysql engine = create_engine( \"mysql://test:test@localhost/test_database\", isolation_level=\"READ_UNCOMMITTED\" ) 실행했더니 잘 동작한다! ","date":"2017-02-09","objectID":"/python-flask-with-sqlalchemy/:4:1","tags":["Python","Flask","SQLAlchemy"],"title":"Python Flask with SQLAlchemy","uri":"/python-flask-with-sqlalchemy/"},{"categories":["Python"],"content":"Sqlalchemy with pymysql 한글깨짐 한글이 깨져 나올때는 utf8 인코딩 설정을 해줘야 한다. create_engine()을 호출할때 파라미터를 수정해주면 간단히 해결된다. 아래처럼 dbhost 파라미터에 charset=utf8을 추가하자 engine = create_engine( \"mysql://test:test@localhost/test_database\u0026charset=utf8\", isolation_level=\"READ_UNCOMMITTED\" ) ","date":"2017-02-09","objectID":"/python-flask-with-sqlalchemy/:4:2","tags":["Python","Flask","SQLAlchemy"],"title":"Python Flask with SQLAlchemy","uri":"/python-flask-with-sqlalchemy/"},{"categories":["Python"],"content":"Reference SQLAlchemy Tutorial [Python] SQLAlchemy 사용하기 SQLAlchemy 시작하기 – Part 1 SQLAlchemy 시작하기 - Part 2 SQLAlchemy in Flask Flask에서 SQLAlchemy 사용하기 ","date":"2017-02-09","objectID":"/python-flask-with-sqlalchemy/:5:0","tags":["Python","Flask","SQLAlchemy"],"title":"Python Flask with SQLAlchemy","uri":"/python-flask-with-sqlalchemy/"},{"categories":["Python"],"content":"BeautifulSoup 설치 Python을 통한 클로링에 대해서 서치해보니, beautifulSoup를 활용한 예제들이 많더라. 우선 설치해보자. $ pip install beautifulSoup4 ","date":"2017-02-04","objectID":"/python-beautifulsoup-%EC%9D%B4%EC%9A%A9-%ED%81%AC%EB%A1%A4%EB%A7%81%ED%95%98%EA%B8%B0/:1:0","tags":["Python","BeautifulSoup","Crawling"],"title":"Python BeautifulSoup 이용 크롤링하기","uri":"/python-beautifulsoup-%EC%9D%B4%EC%9A%A9-%ED%81%AC%EB%A1%A4%EB%A7%81%ED%95%98%EA%B8%B0/"},{"categories":["Python"],"content":"크롤링 시작하기 클리앙의 모두의공원 카테고리의 글을 크롤링해보려 한다. 레퍼런스 사이트내용을 참고해서 아래와 같이 진행해 보았다. 우선 해당 페이지의 모든 html text를 긁어와보자 import requests from bs4 import BeautifulSoup if __name__ == '__main__': url = \"http://www.clien.net/cs2/bbs/board.php?bo_table=park\" source_code = requests.get(url) plain_text = source_code.text print(plain_text) 콘솔창에 엄청나게 길게 출력된 내용을 볼 수 있다. 일단 성공! 그럼 이어서 특정 태그 내용만 골라내보자. 예를 들어 게시물의 번호와 제목만 골라보자 (내용추가 예정) 먼저 BeautifulSoup 라이브러리를 이용하여 html 문서를 파싱한다. ...생략... if __name__ == '__main__': url = \"http://www.clien.net/cs2/bbs/board.php?bo_table=park\" source_code = requests.get(url) plain_text = source_code.text print(plain_text) soup = BeautifulSoup(plain_text, 'lxml') 혹시 아래와 같은 에러를 만난다면 bs4.FeatureNotFound: Couldn't find a tree builder with the features you requested: lxml. Do you need to install a parser library? lxml 라이브러리가 없어 발생한 문제다. 설치하자. $ pip install lxml 계속 진행해보자. 크롬 인스펙터를 이용해서 구조를 파악하고.. 아래와같이 우선 게시물번호와 제목을 가져오기러 했다. ...생략... if __name__ == '__main__': url = \"http://www.clien.net/cs2/bbs/board.php?bo_table=park\" source_code = requests.get(url) plain_text = source_code.text soup = BeautifulSoup(plain_text, 'lxml') for tr in soup.select('tr.mytr'): idx = 0 for td in tr.select('td'): if idx==0: print(\"NUM : \"+ td.string) elif idx==1: print(\"SUBJECT : \"+ td.find('a').text) idx+=1 그 결과물은. NUM : 52750721 SUBJECT : êµ°ë ìë¹µ.. êµ¬ìë¨¹ì ë§ë¬ì£  한글이 깨져나온다. 오랜시간의 사투 결과… 해결책을 찾은것은 plain_text = source_code.text 를 plain_text = source_code.content 로 변경하는 것이었다. 그 결과.. NUM : 52750735 SUBJECT : 미드 에이젼트 오브 쉴드... 완료! ","date":"2017-02-04","objectID":"/python-beautifulsoup-%EC%9D%B4%EC%9A%A9-%ED%81%AC%EB%A1%A4%EB%A7%81%ED%95%98%EA%B8%B0/:2:0","tags":["Python","BeautifulSoup","Crawling"],"title":"Python BeautifulSoup 이용 크롤링하기","uri":"/python-beautifulsoup-%EC%9D%B4%EC%9A%A9-%ED%81%AC%EB%A1%A4%EB%A7%81%ED%95%98%EA%B8%B0/"},{"categories":["Python"],"content":"Reference 파이썬(Python)-취미 프로그래밍, 취미 프로젝트의 시작. 파이썬(Python) - beautifulSoup 으로 html 파싱 [PYTHON 3] Tutorials 25. 웹 크롤러(like Google) 만들기 2 - How to build a web crawler ","date":"2017-02-04","objectID":"/python-beautifulsoup-%EC%9D%B4%EC%9A%A9-%ED%81%AC%EB%A1%A4%EB%A7%81%ED%95%98%EA%B8%B0/:3:0","tags":["Python","BeautifulSoup","Crawling"],"title":"Python BeautifulSoup 이용 크롤링하기","uri":"/python-beautifulsoup-%EC%9D%B4%EC%9A%A9-%ED%81%AC%EB%A1%A4%EB%A7%81%ED%95%98%EA%B8%B0/"},{"categories":["ETC"],"content":"들어가며 Jekyll을 이용하여 블로그를 구성해봅시다. ","date":"2017-01-20","objectID":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/:1:0","tags":["ETC","Jekyll"],"title":"Jekyll3로 블로그 만들기","uri":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["ETC"],"content":"사전준비 ","date":"2017-01-20","objectID":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/:2:0","tags":["ETC","Jekyll"],"title":"Jekyll3로 블로그 만들기","uri":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["ETC"],"content":"Ruby 설치 Jekyll 2 사용 시 v1.9.3 이상 / Jekyll 3 사용 시 v2 이상 저는 2.3.3 버전을 설치했습니다. “설치경로\\bin” 을 환경변수에 추가합시다. Download Link: https://rubyinstaller.org/downloads ","date":"2017-01-20","objectID":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/:2:1","tags":["ETC","Jekyll"],"title":"Jekyll3로 블로그 만들기","uri":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["ETC"],"content":"RubyGems 설치 Ruby 1.9 이상의 버전을 설치하면 RubyGems가 동봉되어 있습니다. (2.3.3 버전을 설치했으므로 패스) Download Link: https://www.python.org/downloads ","date":"2017-01-20","objectID":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/:2:2","tags":["ETC","Jekyll"],"title":"Jekyll3로 블로그 만들기","uri":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["ETC"],"content":"Jekyll 설치하기 $ gem install jekyll ","date":"2017-01-20","objectID":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/:2:3","tags":["ETC","Jekyll"],"title":"Jekyll3로 블로그 만들기","uri":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["ETC"],"content":"Jekyll 템플릿 적용하기 검색해보면 다양한 jekyll 무료 템플릿이 존재합니다. 저는 (lanyon_plus)을 찾아 적용했습니다. 템플릿 적용에 대해서는 아래 포스트를 참고 바랍니다. Jekyll-template-적용하기 ","date":"2017-01-20","objectID":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/:3:0","tags":["ETC","Jekyll"],"title":"Jekyll3로 블로그 만들기","uri":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["ETC"],"content":"서버 구동 Template 설치가 끝나면 해당 폴더 아래로 이동하여 아래 명령어를 수행합시다. $ jekyll serve 이제 브라우저에서 http://127.0.0.1:4000/ (혹은 5000 포트) 에 접속하여 블로그가 잘 보이는지 확인해 봅시다. ","date":"2017-01-20","objectID":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/:4:0","tags":["ETC","Jekyll"],"title":"Jekyll3로 블로그 만들기","uri":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"categories":["ETC"],"content":"Reference https://jekyllrb-ko.github.io/ ","date":"2017-01-20","objectID":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/:5:0","tags":["ETC","Jekyll"],"title":"Jekyll3로 블로그 만들기","uri":"/jekyll3%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}]